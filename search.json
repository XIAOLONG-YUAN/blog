[{"title":"redis面试题","path":"/post/4370f109.html","content":"为什么redis使用单线程反而更快？ 内存操作： redis是一个内存数据，内存的读写数据天生就是快； 单线程模型： 单线程模型避免了多线程上下文切花带来的开销 采用事件驱动的IO多路复用模型： 事件驱动的IO多路复用模型结合了非阻塞IO和事件驱动的优点，非常适合处理大量并发连接的场景。通过事件循环和事件处理器的机制，能高效的管理多个IO流，同时避免了线程上下文切换的开销，是现代高性能服务器架构的核心技术之一。 命令的原子性： 大部分命令都是原子性，命令的原子性和单线程模型可以确保在任何时刻只有一个命令在执行，消除了对复杂的数据结构的保护和锁的需求，提高整体效率。 数据结构优化： redis使用了高效的数据结构，如跳跃表、压缩列表、哈希表等，这些数据结构提供了快速的查找和操作速度，有助于维持高性能。 C语言编写更接近于底层语言 TIP:主要瓶颈是网络IO和CPU的计算能力，而不是线程间的并行处理。在多核CPU环境下，Redis从v4.0开始引入了多线程来处理后台任务（如AOF重写），并在v6.0中增加了对多线程的网络处理支持。 redis有哪些常用的数据类型？ redis常用的数据类型有5种：String、List、Hash、Set、Sorted Set；如下图所示 String: 底层结构叫SDS（Simple Dynamic String），是一个带长度信息的字节数组；规定字符串长度不得超过512M；当字符串长度小于或等于44时，使用embstr形式存储，大于44时，使用raw形式存储； embstr形式存储：SDS的存储一般是连续的（意思就是redisObject对象头和SDS对象连续存在一起，malloc时一起分配）。 raw形式存储：SDS不是连续存储的（需要两次malloc分配） Hash: 存对象 使用字典（dict）。字典由一个哈希表和多个压缩列表或字典组成，当元素较少时使用压缩列表（ziplist），节省内存；当元素较多时转换成普通的哈希表。7.0+版本较少时使用的紧凑列表listpack； List: 可以做队列 使用压缩列表（ziplist）或 QuickList（快速列表）。对于小列表，使用压缩列表来节省空间；对于大列表，则使用双向链表。7.0+版本压缩列表（ziplist）替换为紧凑列表（listpack）； ZSet: 存储的value是不能重复的，分值score是可以重复的； 使用字典（dict）和跳跃表（skiplist）。字典用来存储Value和分数Score的映射，跳跃表用来按照分数排序；当数据比较少的时候用ziplist存储，否则用跳跃表。 Set: 有去重的功能 使用整数集合（intset）或字典（dict）。当集合中的所有元素都可以被表示为整数时，使用整数集合来节省内存；当集合中有非整数元素时，转换成字典结构 Stream 使用字典和快速链表（quicklist）。每个流元素存储在快速链表中，整个流则是一个字典，其中键是流ID，值是快速链表 有序集合（Zset）底层是如何实现的？ 有序集合是由hash 字典+ （ziplist（压缩列表）或 skiplist（跳跃表））组成。hash字典用来存储Value和分数Score的映射； 压缩列表ziplist本质上就是一个字节数组，压缩列表是一块连续的内存空间，没有任何冗余间隙； 跳跃表skiplist是一种有序的双向连链表结构； tip: 只有完全满足以下两个条件才能使用ziplist，反之则使用skiplist 有序集合的元素个数小于128个 有序集合的所有元素成员的长度都必须小于64字节； redis如何保证数据不丢失？ 保存数据不丢失主要在两个方面：1. 持久化；2. 集群部署 持久化： RDB持久化：快照方式持久化，将某一个时刻的内存数据，以二进制的方式写入磁盘； 优点： 速度快： 空间占用小 恢复速度快 可靠性高 缺点： 实时性差 数据可能会丢失 AOF持久化：文件追加持久化，记录所有非查询操作命令，并以文本的形式追加； 优点： 数据不容易丢失 实时性好 数据可读性强 缺点： 写入性能低 占用磁盘空间大 AOF文件可能会出现损坏； 混合持久化：RDB+AOF混合方式的持久化，在写入的时候，先把当前的数据以RDB的形式写入文件的开头，再将后序的操作命令以AOF的格式存入文件； TIP: 总结下RDB和AOF的优缺点主要在5个方面： 写入方式：RDB是通过快照的形式，以二进制的方式写入磁盘中，AOF是通过追加命令的形式，以命令的方式写入在AOF文件中； 数据恢复：RBD是某一时间点的数据，可以直接加载到内存中快速恢复；AOF则需要逐条执行命令恢复，需要时间长； 数据完整性：RDB文件保存的是某一时间点的数据快照，宕机后，可能会丢失一部分数据；AOF是记录redis所有的命令，因此AOF丢失的命令会少很多； 文件大小：RDB文件以二进制形式存储，文件小；AOF文件存储的是命令内容，则文件大； 性能影响：AOF文件追加写的方式不会阻塞；RDB文件在快照时可能会阻塞redis服务； 集群部署： 主从同步 哨兵模式 redis 集群 redis的内存淘汰策略有哪些？什么时候触发呢？ redis在3种情况下会触发内存的淘汰策略： 当写操作内存超过限制：我们可以通过config get maxmemory查询redis能使用的最大内存值，当使用超过这个maxmemory时就会触发内存淘汰策略； 启用AOF重写操作：如果使用AOF持久化方式并开启AOF重写功能时，那么在执行AOF重写过程中会触发内存淘汰策略。AOF重写是将AOF原来的文件重写为一份更为紧凑的格式，减少内存的占用； 通过命令主动释放内存：通过主动执行MEMORY PURGE命令释放内存； 淘汰策略： noeviction：不淘汰任何数据，当内存不足时，新增操作会报错，Redis 默认内存淘汰策略； allkeys-lru：淘汰整个键值中最久未使用的键值； allkeys-random：随机淘汰任意键值； allkeys-lfu：淘汰整个键值中最少使用的键值。 volatile-lru：淘汰所有设置了过期时间的键值中最久未使用的键值； volatile-lfu：淘汰所有设置了过期时间的键值中，最少使用的键值 volatile-random：随机淘汰设置了过期时间的任意键值； volatile-ttl：优先淘汰更早过期的键值; TIP: LRU是在一段时间范围内最久未使用，基于时间的维度；LFU是在一段时间范围内使用次数最少的，基于访问频率的维度； 缓存雪崩、缓存击穿、缓存穿透是什么？怎么解决？ 缓存雪崩：指缓存中存在大量的键同时过期或失效，导致大量请求直接访问到数据库或服务； 原因： 大量缓存键同时过期 缓存服务器故障 解决方案： 设置随机过期时间 实现缓存预热：在服务启动或者缓存失效前，提前加载热点数据； 使用分布式缓存集群：减少单节点压力，提高系统的可用性和抗压性； 服务熔断或降级 增加监控和告警机制 缓存击穿：某个热点数据过期或失效，导致大量数据同时访问数据库或服务； 原因： 热点数据失效 并发访问热点数据 解决方案： 设置热点数据永不过期或过期时间比较长 加互斥锁或分布式锁；加分布式锁，只有一个线程能进入； 限制并发访问；限制热点数据并发访问的量； 缓存穿透：恶意请求查询不存在缓存和数据库中的数据，导致这些请求直接访问数据库； 原因： 恶意请求 高并发请求（正常请求）：当有大量的并发请求通过查询不存的数据时，可能会导致缓存无法命中，从而触发缓存穿透； 解决方案： 使用布隆过滤器： 缓存空值处理：可以将查询出来的空值做一个短期的缓存，防止相同的请求打到数据库； 异步缓存加载：缓存未命中时，可以异步加载数据到缓存中，通过使用分布式锁来保证只有一个线程去加载数据，避免重复加载； 限制恶意请求：通过访问频率控制、验证码等手段","tags":["面试","redis"],"categories":["redis"]},{"title":"mysql面试题","path":"/post/e0f8559b.html","content":"mysql中有哪些锁？ 共享锁（Shared Locks 或 S 锁）： 共享锁允许多个事务同时读取同一数据，但不允许任何事务在同一数据上进行写操作； 排他锁（Exclusive Locks 或 X 锁）： 排他锁阻止其他事务读取或修改同一数据，当一个事务需要更新或删除数据时，它会获取排他锁； 意向共享锁（Intent Shared Locks 或 IS 锁）&amp;&amp; 意向排他锁（Intent Exclusive Locks 或 IX 锁）： 加锁的时候可能锁某一行或几行的数据，也可能锁整个表，但共享锁只能和共享锁兼容，排他锁和两者（共享锁、排他锁）都不兼容。举一个极端的例子，如果共享锁锁表（全表扫描查询），难道需要一行行遍历看数据是否被排他锁锁过吗？同理，排他锁锁表时，就需要一行行遍历是否存在数据被共享锁或者排他锁占用。 所以提出了IS锁和IX锁，减少行级锁和表级锁的冲突，以下是共享锁、排他锁、意向共享锁、意向排他锁的兼容关系 X（排他锁） IX（意向排他锁） S（共享锁） IS（意向共享锁） X ❌ ❌ ❌ ❌ IX ❌ ✅ ❌ ✅ S ❌ ❌ ✅ ✅ IS ❌ ✅ ✅ ✅ Tip： IX和IX能兼容是因为多个IX锁时获取不同行数据的行锁，可以同时存在；同理，IX和IS兼容也是一样； 记录锁（Record Locks）： 锁定特定记录或行，锁定的行数是固定的； 间隙锁（Gap Locks）：左开右开 间隙锁的目的是在RR级别下，防止幻读，幻读的产生是当前事务多次的查询结果的数量不一致；间隙锁的目的就是保证当前范围内的数据不会被更改，所以它会锁住某些区间的数据； 临键锁（Next-Key Locks）：左开右闭 等于记录锁+间隙锁，所以我们只需要知道两个锁的定义就行，Mysql在隔离级别为RR时，默认是Next-key锁； 表级锁（Table Locks）： 行级锁（Row Locks）： 这种锁是最细粒度的锁，只锁定被事务访问的具体行。Innodb存储引擎支持行级锁； 页级锁（Page Locks）： 页级锁锁定的是数据库页，这是介于行级锁和表级锁之间的中间级别。某些存储引擎可能会使用页级锁，但InnoDB主要使用行级锁； 索引底层是如何实现的？ Mysql中默认的存储引擎是Innodb，其索引是使用B+树实现的。B+树是一种多路搜索树，它的叶子节点存储了所有的数据行信息，叶子节点之间使用指针连接，方便范围查询和排序等操作，非叶子节点存储的是索引字段的值（主键索引存存的是id）； 为什么要选择B+树： 查询效率： 内存：B+树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比B树（即存数据又存索引）大大节省了内存空间 IO操作：B+树的层级比B树更少，查询所需的IO操作更少； 插入和删除效率： B+树相比于B树新增和删除节点不用复杂的结构变化； 查询范围： B+树的叶子节点有指针连接方便进行范围查找 聚簇索引和非聚簇索引的区别？ 聚簇索引和非聚簇索引的区别主要在数据的存储和查询： 数据存储： 聚簇索引（也即主键索引）的叶子节点存储的是主键对应的一行完整的数据，非聚簇索引（非主键索引）的叶子节点存储的是主键值，然后回表查询主键信息； 范围查询： 聚簇索引中的数据行与索引行一一对应的，因此聚簇索引通常比非聚簇索引更适合范围查询，而非聚簇索引需进行而进行二次查询：首先查找索引，然后查找数据行，这会导致性能问题，特别是大型表上进行范围查询； 什么情况会导致索引失效？ 不符合最左匹配原则 使用列运算 使用函数 使用类型转换 is not null 错误的模糊查询 mysql事务有哪些特性？ 原子性（A）:事务中执行的操作要么全部成功，要么全部失败； 一致性（C）：事务执行前后事务的一致性没有被破坏，只能从一个一致性状态到另一个一致性状态；这里常说A转账B的问题，不管转账成功失败，A+B的总金额应该是不变的 隔离性（I）：事务之间相互隔离，每个事务对其他事务的操作都是透明的； 持久性（D）：事务完成后，对数据库的修改将永久保存在数据库中，即使系统故障也不会丢失； 如何保证事务四大特性（ACID）? 原子性：原子性是通过undo log（回滚日志）保证，InnoDB使用日志（undo log）来记录事务从开始到结束的所有操作，当事务提交失败时，通过undo log日志来回滚执行的数据，来确保事务的原子性； 持久性：持久性是通过redo log（重做日志）保证，在事务提交之前，innodb会将事务的修改操作先写入redo log 中，然后再将数据写入磁盘。即使在系统崩溃或断电的情况下，innodb可以通过重放事务日志来恢复数据，来确保事务的持久性。 隔离性：MVCC（多版本并发控制）和锁机制来保证； 一致性：一致性是通过各种约束，如主键，唯一性约束等，同时加上事务的持久性、原子性、隔离性同时来保证一致性； 不可重复读和幻读的区别？ 不可重复读是指多次查询同一行数据，每次查询出来的结果都不同； 幻读是指范围查询时，会出现数据的个数总是在变化； 解决方案： 不可重复读通常通过提高隔离级别为RR或者手动使用行锁； 幻读：通过提高隔离级别为串行或者手动SELECT ... FOR UPDATE或SELECT ... LOCK IN SHARE MODE时，InnoDB会在行级加锁的同时，也可能加间隙锁 MVCC是什么？能解决幻读吗？ MVCC是一种并发控制机制，主要用来解决幻读的问题。MVCC的核心思想是将每个事务的读操作与写操作解耦，通过保存数据的历史版本来控制并发，每个事务都会创建一个读视图（read-view），用于确定在事务开始时可见的数据版本，旧版本的事务会保存在undo log中（mysql有undo log缓存） 读操作：当一个事物执行SELECT语句时，会根据读视图的版本号与数据行的版本号就行比对，只读取在事务之前已经提交的数据行。这样，即使其他事务正在并发的插入或者删除数据，事务仍然可以读取到一致的数据。 写操作：当一个事务执行INSERT、UPDATE或DELETE语句时，会生成新的数据版本，并将旧版本的数据保存在undo log中.这样，其他事务在读取数据时仍然可以访问到旧版本的数据，从而避免幻读的问题； RR+MVCC能解决幻读吗？不能，即使是在RR级别下，MVCC虽然能解决大部分的幻读问题，但依然存在部分幻读问题无法解决； 在RR模式下，mysql 的innodb引擎读取数据有两种方式快照读（Snapshot Read）和当前读（Current Read）； 快照读：读取开启事务时的已经提交的数据，即使后面有修改，当前事务也只能读取这个快照版本之前的事务数据； 当前读：通过 SELECT ... FOR UPDATE或SELECT ... LOCK IN SHARE MODE方式执行的查询，会读取最新提交的数据，而不是开启事务之前版本的数据； TIP：快照读主要适用于需要读取一致性数据的场景，比如报表生成或分析，其中数据的一致性比绝对实时性更重要；当前读适用于需要读取最新数据的场景，比如实时交易系统或需要立即反应最新数据变化的业务逻辑； 解决的方案： 使用串行化（Serializable）隔离级别：官方推荐方案，但这种解决方案，并发性能比较低。 RR + 锁：使用 RR 隔离级别，通过 SELECT ... FOR UPDATE加锁，可以保证在查询过程中，不会有别的事务插入数据； 如何保证数据库和缓存双写一致？ 解决缓存和数据库一致问题的常见解决方案有以下 4 种： 先修改数据库，后更新缓存。 先更新缓存，后修改数据库。 先修改数据库，后删除缓存。 先删除缓存，后修改数据库。 前3种都存在第一步执行成功第二步执行失败的问题，所以一般都是使用第4种，先删除缓存在更新数据库的方案，最起码能保证数据的一致性问题；但是这种方案其实也有一些问题，会存在旧值覆盖缓存的问题（先删了缓存，另一个线程看没有缓存，查库更新缓存，导致缓存中是旧值，数据库是新值）；如果我们想要达到最大程度的解决双写一致性问题，最终的解决方案就是MQ+延迟双删策略； 引入MQ保证消息不回丢失； 通过先删除缓存，修改数据库； 延时一段时间再次删除缓存； Undo log（回滚日志） 和 redo log（重做日志）是由什么区别？什么时候落盘的? Undo log保证了事务的原子性；redo log保证事务的持久性； undo log在事务开始修改数据时就会生成undo log日志记录，主要记录的是修改前的数据；redo log则是事务开始修改数据时，主要记录的执行的sql; Redo log需要实时的flush到磁盘（Redo log的flush写入磁盘时机是灵活的，InnoDB会根据配置和系统状态决定何时将Redo log从内存flush到磁盘，通常是在事务提交前后、定期或当Redo log buffer达到一定比例时）；undo log不需要实时的落盘，因为undo log是事务的一部分，事务提交后仍需要保存一段时间，以便其他事务能够读取旧的行版本（MVCC）。","tags":["mysql","面试"],"categories":["mysql"]},{"title":"个人能力演变讨论","path":"/post/c3bc3481.html","content":"引言一般公司中都会有职级相关的等级，例如初级、中级、高级等等类似的岗位任职资格，但是生活中总有人卡在某一个等级，有的人却能顺风顺水，到底是因为什么呢？我们下面要讲的是个人能力演变的底层逻辑，通过借鉴阿里的职级来介绍相应的能力层级。 职级 能力特点 业务能力 思维能力 写作能力 变革能力 P4,P5….. 为什么人的能力千千万，我们却只用“业务能力”、“思维能力”、“协作能力”、“变革能力”这四种能力来做衡量维度？ P4级别： 职级 思维形象 能力特点 业务能力 思维能力 写作能力 变革能力 P4 点 初识事 4无1带 思维来源：从小养成的“听话”习惯； 心理分析：自我价值认知是“完成”，从“表扬”中获得满足感； 行事方式：追求快速完成 思维特点：让干啥干啥，不问为什么 管理者视角：能帮你干事，不能帮你想事。经常听不懂任务，需要过程辅导和监督； Tip: P4只关注事情本事，不关注事情的来源和事情的结果；4无1带是指无方法、无方向、无能力、无经验，需要人带； P5级别： 职级 思维形象 能力特点 业务能力 思维能力 写作能力 变革能力 P5 动点 事推人 独立交付 思辨能力 思维来源：之前新人期被教育过，明白了不是快就好 心理分析：干多了就腻了，关注怎么更省事轻松。做同样的事，要比小白强； 行事方式：会总结方法，甚至发明工具。除了速度，更看重质量； 思维特点：不想做无用功，所以开始关注正确理解任务，提高客户满意度； 管理者视角：只要说清楚要求，大多数时候能独立完成任务。但很少能超出预期。 Tip: P5心中有用户，能独立负责一摊子事，但还是属于被动的执行者；容易陷入研究“技术”的陷阱，去死扣所谓的专业； P6级别： 职级 思维形象 能力特点 业务能力 思维能力 写作能力 变革能力 P6 自运行点 人推事 主动担当、独挡一面 konw why 思维来源：通过大量重复执行，开始摸索任务的规律； 心理分析：领导动嘴，事全我干，凭什么？我想知道管理的秘密； 行事方式：会去理解做事的目的是什么，以此来指引行为，交付结果，体现价值； 思维特点：知道了为什么要做事，就可以自己做主了。所以开始观察和探索；（什么时刻，发生了什么问题，领导是怎么解决问题，是如何形成闭环） 管理者视角：主动性越来越强，有时都可以给自己提醒。有一点管理者的味道了； Tip: 知道为什么做，能主动发现问题，并解决问题。—– 这一阶段，人开始主导事。 P7级别： 职级 思维形象 能力特点 业务能力 思维能力 写作能力 变革能力 P7 线 策略做事 单线打通 有策略、有取舍 上下游联动 推动产品、服务、流程优化 思维来源：我看懂了事的为什么，才发现原来每个事里都有很多人在运动； 心理分析：原来事能不能成，关键不在事上，而在人上； 行事方式：从做人的角度去考虑做事，在做事之前，就能想到人的问题怎么处理； 思维特点：所以开始策略思考问题，想成事，哪些人人可用，哪些人别碰； 管理者视角：已经能从事里面抬头来，看到事是人链接的工具，做事更有套路了； Tip: 能前后链条一起看，会讲策略地拿结果。—– 这一阶段，我在事中看到了人 总结： 职级 能力特点 业务能力 思维能力 写作能力 变革能力 P4 点 初识事 4无1带 P5 动点 事推人 独立交付 思辨能力 P6 自运行点 人推事 主动担当、独挡一面 konw why P7 线 策略做事 单线打通 有策略、有取舍 上下游联动","tags":["职业发展"]},{"title":"hexo搭建博客流程","path":"/post/4a17b156.html","content":"本地环境搭建 以hexo官方文档为准：hexo环境准备 创建一个github page项目 参考Stellar 说明文档：创建github page页面 &amp;&amp; 开启github page教程 Tip: 创建github page页面的项目一定要设置为public，如果设置为private会导致通过https://xxxx.github.io/这种github提供的域名无法访问对应的页面。 创建一个private的项目，用于存放 设置自定义域名 使用 Vercel 部署，vercel类似于github page，但远比github page强大，速度也快得多得多，而且将Github授权给vercel后，可以达到最优雅的发布体验，只需将代码轻轻一推，项目就自动更新部署了 域名配置 使用七牛云搭建图床 PicGo 图片压缩插件 tinypng","tags":["hexo"],"categories":["hexo"]}]